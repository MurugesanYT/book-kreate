
import { ref, get, set, push, remove, update } from 'firebase/database';
import { database } from '../firebase';
import { Book, Chapter } from './types';
import { v4 as uuidv4 } from 'uuid';

export const getAllBooks = async (): Promise<Book[]> => {
  try {
    const snapshot = await get(ref(database, 'books'));
    if (snapshot.exists()) {
      const books = snapshot.val();
      return Object.entries(books).map(([id, book]: [string, any]) => ({
        ...book,
        id,
      }));
    }
    return [];
  } catch (error) {
    console.error('Error fetching all books:', error);
    throw error;
  }
};

// Keep the existing getBooks function as well for compatibility
export const getBooks = getAllBooks;

export const getBook = async (id: string): Promise<Book | null> => {
  try {
    const snapshot = await get(ref(database, `books/${id}`));
    if (snapshot.exists()) {
      return { ...snapshot.val(), id };
    }
    return null;
  } catch (error) {
    console.error(`Error fetching book with id ${id}:`, error);
    throw error;
  }
};

export const createBook = async (book: Omit<Book, 'id'>): Promise<Book> => {
  try {
    const newBookRef = push(ref(database, 'books'));
    const newBook = { ...book, id: newBookRef.key };
    await set(newBookRef, book);
    return newBook as Book;
  } catch (error) {
    console.error('Error creating book:', error);
    throw error;
  }
};

export const updateBook = async (id: string, bookData: Partial<Book>): Promise<void> => {
  try {
    await update(ref(database, `books/${id}`), bookData);
  } catch (error) {
    console.error(`Error updating book with id ${id}:`, error);
    throw error;
  }
};

export const deleteBook = async (id: string): Promise<void> => {
  try {
    await remove(ref(database, `books/${id}`));
  } catch (error) {
    console.error(`Error deleting book with id ${id}:`, error);
    throw error;
  }
};

export const addChapter = async (bookId: string, chapter: Omit<Chapter, 'id'>): Promise<Chapter> => {
  try {
    const chapterId = uuidv4();
    const newChapter = { ...chapter, id: chapterId };
    
    const bookSnapshot = await get(ref(database, `books/${bookId}`));
    if (!bookSnapshot.exists()) {
      throw new Error(`Book with id ${bookId} does not exist`);
    }
    
    const book = bookSnapshot.val();
    const chapters = book.chapters || [];
    chapters.push(newChapter);
    
    await update(ref(database, `books/${bookId}`), { chapters });
    return newChapter;
  } catch (error) {
    console.error(`Error adding chapter to book with id ${bookId}:`, error);
    throw error;
  }
};

export const updateChapter = async (bookId: string, chapterId: string, chapter: Partial<Chapter>): Promise<void> => {
  try {
    const bookSnapshot = await get(ref(database, `books/${bookId}`));
    if (!bookSnapshot.exists()) {
      throw new Error(`Book with id ${bookId} does not exist`);
    }
    
    const book = bookSnapshot.val();
    const chapters = book.chapters || [];
    const chapterIndex = chapters.findIndex((c: Chapter) => c.id === chapterId);
    
    if (chapterIndex === -1) {
      throw new Error(`Chapter with id ${chapterId} does not exist in book with id ${bookId}`);
    }
    
    chapters[chapterIndex] = { ...chapters[chapterIndex], ...chapter };
    await update(ref(database, `books/${bookId}`), { chapters });
  } catch (error) {
    console.error(`Error updating chapter with id ${chapterId} in book with id ${bookId}:`, error);
    throw error;
  }
};

export const deleteChapter = async (bookId: string, chapterId: string): Promise<void> => {
  try {
    const bookSnapshot = await get(ref(database, `books/${bookId}`));
    if (!bookSnapshot.exists()) {
      throw new Error(`Book with id ${bookId} does not exist`);
    }
    
    const book = bookSnapshot.val();
    const chapters = book.chapters || [];
    const updatedChapters = chapters.filter((c: Chapter) => c.id !== chapterId);
    
    await update(ref(database, `books/${bookId}`), { chapters: updatedChapters });
  } catch (error) {
    console.error(`Error deleting chapter with id ${chapterId} from book with id ${bookId}:`, error);
    throw error;
  }
};

// Add new function for bulk chapter generation
export const generateMultipleChapters = async (bookId: string, numberOfChapters: number): Promise<Chapter[]> => {
  try {
    const bookSnapshot = await get(ref(database, `books/${bookId}`));
    if (!bookSnapshot.exists()) {
      throw new Error(`Book with id ${bookId} does not exist`);
    }
    
    const book = bookSnapshot.val();
    const existingChapters = book.chapters || [];
    const newChapters: Chapter[] = [];
    
    for (let i = 1; i <= numberOfChapters; i++) {
      const chapterNumber = existingChapters.length + i;
      const chapterId = uuidv4();
      const newChapter: Chapter = {
        id: chapterId,
        title: `Chapter ${chapterNumber}`,
        content: `This is the content for Chapter ${chapterNumber}. It will be generated by AI based on the book's context.`,
        bookId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        order: chapterNumber
      };
      newChapters.push(newChapter);
    }
    
    const updatedChapters = [...existingChapters, ...newChapters];
    await update(ref(database, `books/${bookId}`), { chapters: updatedChapters });
    
    return newChapters;
  } catch (error) {
    console.error(`Error generating multiple chapters for book with id ${bookId}:`, error);
    throw error;
  }
};
